// This file is auto-generated by @hey-api/openapi-ts

/**
 * page info for paginated endpoints
 */
export type Pagination = {
	/**
	 * total number of results for the query
	 */
	total?: number;
	/**
	 * the maximum number of results
	 */
	limit?: number;
	/**
	 * the starting point for this
	 */
	offset?: number;
	/**
	 * fields for the next page, if any.
	 * Null if this is the last page.
	 *
	 */
	next?: {
		/**
		 * the offset for the next page
		 */
		offset?: number;
		/**
		 * the same as the above limit, for consistency
		 */
		limit?: number;
		/**
		 * the assembled url for the next page,
		 * with query parameters already included.
		 *
		 */
		url?: string;
	} | null;
};

export type PaginatedList = {
	items?: Array<{
		[key: string]: unknown;
	}>;
	_pagination?: Pagination;
};

export type User = {
	/**
	 * The user's name
	 */
	name?: string;
	/**
	 * Whether the user is an admin
	 */
	admin?: boolean;
	/**
	 * The names of roles this user has
	 */
	roles?: Array<string>;
	/**
	 * The names of groups where this user is a member
	 */
	groups?: Array<string>;
	/**
	 * The user's notebook server's base URL, if running; null if not.
	 */
	server?: string;
	/**
	 * The currently pending action, if any
	 */
	pending?: "spawn" | "stop";
	/**
	 * Timestamp of last-seen activity from the user
	 */
	last_activity?: string;
	/**
	 * The servers for this user.
	 * By default: only includes _active_ servers.
	 * Changed in 3.0: if `?include_stopped_servers` parameter is specified,
	 * stopped servers will be included as well.
	 *
	 */
	servers?: {
		[key: string]: Server;
	};
	/**
	 * Authentication state of the user. Only available with admin:users:auth_state
	 * scope. None otherwise.
	 *
	 */
	auth_state?: {
		[key: string]: unknown;
	};
};

export type Server = {
	/**
	 * The server's name. The user's default server has an empty name ('')
	 */
	name?: string;
	/**
	 * Whether the server is ready for traffic.
	 * Will always be false when any transition is pending.
	 *
	 */
	ready?: boolean;
	/**
	 * Whether the server is stopped. Added in JupyterHub 3.0,
	 * and only useful when using the `?include_stopped_servers`
	 * request parameter.
	 * Now that stopped servers may be included (since JupyterHub 3.0),
	 * this is the simplest way to select stopped servers.
	 * Always equivalent to `not (ready or pending)`.
	 *
	 */
	stopped?: boolean;
	/**
	 * The currently pending action, if any.
	 * A server is not ready if an action is pending.
	 *
	 */
	pending?: "spawn" | "stop";
	/**
	 * The URL path where the server can be accessed
	 * (typically /user/:name/:server.name/).
	 * Will be a full URL if subdomains are configured.
	 *
	 */
	url?: string;
	/**
	 * The URL path for an event-stream to retrieve events during a spawn.
	 *
	 */
	progress_url?: string;
	/**
	 * The full URL of the server (`https://hub.example.org/user/:name/:servername`).
	 * `null` unless JupyterHub.public_url or subdomains are configured.
	 *
	 * Added in 5.0.
	 *
	 */
	full_url?: string | null;
	/**
	 * The full URL for the progress events (`https://hub.example.org/hub/api/users/:name/servers/:servername/progress`).
	 * `null` unless JupyterHub.public_url is configured.
	 *
	 * Added in 5.0.
	 *
	 */
	full_progress_url?: string | null;
	/**
	 * UTC timestamp when the server was last started.
	 */
	started?: string;
	/**
	 * UTC timestamp last-seen activity on this server.
	 */
	last_activity?: string;
	/**
	 * Arbitrary internal state from this server's spawner. Only available on the hub's users list or get-user-by-name method, and only with admin:users:server_state scope. None otherwise.
	 */
	state?: {
		[key: string]: unknown;
	};
	/**
	 * User specified options for the user's spawned instance of a single-user server.
	 */
	user_options?: {
		[key: string]: unknown;
	};
};

/**
 * The model for the entity making the request.
 * Extends User or Service model to add information about the specific credentials (e.g. session or token-authorised scopes).
 *
 */
export type RequestIdentity = (
	| ({
			kind?: "user";
	  } & User)
	| ({
			kind?: "service";
	  } & Service)
) & {
	/**
	 * The session id associated with the request's OAuth token, if any.
	 * null, if the request token not associated with a session id.
	 *
	 * Added in 2.0.
	 *
	 */
	session_id?: string | null;
	/**
	 * The list of all expanded scopes the request credentials have access to.
	 *
	 * Added in 2.0.
	 *
	 */
	scopes?: Array<string>;
	/**
	 * The id of the token authorizing the request, if any.
	 * This id can be used to revoke the token via the API.
	 * Null if the request is not authorized with a token.
	 *
	 * Added in 5.0.
	 *
	 */
	token_id?: string | null;
};

export type Group = {
	/**
	 * The group's name
	 */
	name?: string;
	/**
	 * The names of users who are members of this group
	 */
	users?: Array<string>;
	/**
	 * Group properties (a dictionary).
	 *
	 * Unused by JupyterHub itself,
	 * but an extension point to store information about groups.
	 *
	 * Added in JupyterHub 3.2.
	 *
	 */
	properties?: {
		[key: string]: unknown;
	};
	/**
	 * The names of roles this group has
	 */
	roles?: Array<string>;
};

export type Service = {
	/**
	 * The service's name
	 */
	name?: string;
	/**
	 * Whether the service is an admin
	 */
	admin?: boolean;
	/**
	 * The names of roles this service has
	 */
	roles?: Array<string>;
	/**
	 * The internal url where the service is running
	 */
	url?: string;
	/**
	 * The proxied URL prefix to the service's url
	 */
	prefix?: string;
	/**
	 * The PID of the service process (if managed)
	 */
	pid?: number;
	/**
	 * The command used to start the service (if managed)
	 */
	command?: Array<string>;
	/**
	 * Additional information a deployment can attach to a service.
	 * JupyterHub does not use this field.
	 *
	 */
	info?: {
		[key: string]: unknown;
	};
};

/**
 * Subset of Server model present in Share responses
 */
export type SharedServer = {
	/**
	 * the server name. '' for the default server.
	 */
	name?: string;
	/**
	 * the server's URL (path only when not using subdomains)
	 */
	url?: string;
	/**
	 * The full URL of the server (`https://hub.example.org/user/:name/:servername`).
	 * `null` unless JupyterHub.public_url or subdomains are configured.
	 *
	 */
	full_url?: string | null;
	/**
	 * whether the server is ready
	 */
	ready?: boolean;
	/**
	 * the server's owner
	 */
	user?: {
		name?: string;
	};
};

/**
 * A single sharing permission.
 * There is at most one of these objects per (server, user) or (server, group) combination.
 *
 */
export type Share = {
	/**
	 * the server granting shared access
	 */
	server?: SharedServer;
	/**
	 * the scopes granted by this Share
	 */
	scopes?: Array<string>;
	/**
	 * the group being shared with (exactly one of 'user' or 'group' will be non-null, the other will be null)
	 */
	group?: {
		name?: string;
	} | null;
	/**
	 * the user being shared with (exactly one of 'user' or 'group' will be non-null, the other will be null)
	 */
	user?: {
		name?: string;
	} | null;
	/**
	 * when the share was first granted
	 */
	created_at?: string;
};

/**
 * A single sharing code. There is at most one of these objects per (server, user) or (server, group) combination.
 */
export type ShareCode = {
	/**
	 * the server granting shared access
	 */
	server?: SharedServer;
	/**
	 * the scopes granted by this Share
	 */
	scopes?: Array<string>;
	/**
	 * the share-code's id.
	 * Can be used to revoke share codes.
	 *
	 */
	id?: string;
	/**
	 * when the share code was issued
	 */
	created_at?: string;
	/**
	 * When the share code will expire,
	 * always in the future.
	 * `null` if the code does not expire.
	 *
	 */
	expires_at?: string | null;
};

export type Token = {
	/**
	 * The id of the API token. Used for modifying or deleting the token.
	 */
	id?: string;
	/**
	 * The user that owns a token (undefined if owned by a service)
	 */
	user?: string;
	/**
	 * The service that owns the token (undefined of owned by a user)
	 */
	service?: string;
	/**
	 * Deprecated in JupyterHub 3, always an empty list. Tokens have 'scopes' starting from JupyterHub 3.
	 */
	roles?: Array<string>;
	/**
	 * List of scopes this token has been assigned. New in JupyterHub 3. In JupyterHub 2.x, tokens were assigned 'roles' instead of scopes.
	 */
	scopes?: Array<string>;
	/**
	 * A note about the token, typically describing what it was created for.
	 */
	note?: string;
	/**
	 * Timestamp when this token was created
	 */
	created?: string;
	/**
	 * Timestamp when this token expires. Null if there is no expiry.
	 */
	expires_at?: string;
	/**
	 * Timestamp of last-seen activity using this token.
	 * Can be null if token has never been used.
	 *
	 */
	last_activity?: string;
	/**
	 * The session id associated with the token, if any.
	 * Only used for tokens set during oauth flows.
	 *
	 * Added in 2.0.
	 *
	 */
	session_id?: string | null;
};

export type NewToken = {
	/**
	 * The token itself. Only present in responses to requests for a new token.
	 */
	token?: string;
	/**
	 * The id of the API token. Used for modifying or deleting the token.
	 */
	id?: string;
	/**
	 * The user that owns a token (undefined if owned by a service)
	 */
	user?: string;
	/**
	 * The service that owns the token (undefined of owned by a user)
	 */
	service?: string;
	/**
	 * Deprecated in JupyterHub 3, always an empty list. Tokens have 'scopes' starting from JupyterHub 3.
	 */
	roles?: Array<string>;
	/**
	 * List of scopes this token has been assigned. New in JupyterHub 3. In JupyterHub 2.x, tokens were assigned 'roles' instead of scopes.
	 */
	scopes?: Array<string>;
	/**
	 * A note about the token, typically describing what it was created for.
	 */
	note?: string;
	/**
	 * Timestamp when this token was created
	 */
	created?: string;
	/**
	 * Timestamp when this token expires. Null if there is no expiry.
	 */
	expires_at?: string;
	/**
	 * Timestamp of last-seen activity using this token.
	 * Can be null if token has never been used.
	 *
	 */
	last_activity?: string;
	/**
	 * The session id associated with the token, if any.
	 * Only used for tokens set during oauth flows.
	 *
	 * Added in 2.0.
	 *
	 */
	session_id?: string | null;
};

/**
 * username
 */
export type UserName = string;

/**
 * group name
 */
export type GroupName = string;

/**
 * name given to a named-server (empty string for default server).
 *
 * Note that depending on your JupyterHub infrastructure there are limitations to `server_name`. Default spawner with K8s pod will not allow Jupyter Notebooks to be spawned with a name that contains more than 253 characters (keep in mind that the pod will be spawned with extra characters to identify the user and hub).
 *
 */
export type ServerName = string;

/**
 * Return a number of results, starting at the specified offset.
 * Can be used with limit to paginate.
 * If unspecified, return all items.
 *
 */
export type PaginationOffset = number;

/**
 * Return a finite number of results.
 * Can be used with offset to paginate.
 * If unspecified, use api_page_default_limit.
 *
 */
export type PaginationLimit = number;

/**
 * name of the user who owns the shared server
 */
export type SharedServerOwner = string;

/**
 * name of the shared server
 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
 *
 */
export type SharedServerName = string;

export type GetApiData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/";
};

export type GetApiResponses = {
	/**
	 * The JupyterHub version
	 */
	200: {
		/**
		 * The version of JupyterHub itself
		 */
		version?: string;
	};
};

export type GetApiResponse = GetApiResponses[keyof GetApiResponses];

export type GetInfoData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/info";
};

export type GetInfoResponses = {
	/**
	 * Detailed JupyterHub info
	 */
	200: {
		/**
		 * The version of JupyterHub itself
		 */
		version?: string;
		/**
		 * The Python version, as returned by sys.version
		 */
		python?: string;
		/**
		 * The path to sys.executable running JupyterHub
		 */
		sys_executable?: string;
		authenticator?: {
			/**
			 * The Python class currently active for JupyterHub Authentication
			 */
			class?: string;
			/**
			 * The version of the currently active Authenticator
			 */
			version?: string;
		};
		spawner?: {
			/**
			 * The Python class currently active for spawning single-user notebook servers
			 */
			class?: string;
			/**
			 * The version of the currently active Spawner
			 */
			version?: string;
		};
	};
};

export type GetInfoResponse = GetInfoResponses[keyof GetInfoResponses];

export type GetCurrentUserData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/user";
};

export type GetCurrentUserResponses = {
	/**
	 * The authenticated user or service's model is returned
	 * with additional information about the permissions associated with the request token.
	 *
	 */
	200: RequestIdentity;
};

export type GetCurrentUserResponse =
	GetCurrentUserResponses[keyof GetCurrentUserResponses];

export type GetUsersData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Return only users who have servers in the given state.
		 * If unspecified, return all users.
		 *
		 * active: all users with any active servers (ready OR pending)
		 * ready: all users who have any ready servers (running, not pending)
		 * inactive: all users who have *no* active servers (complement of active)
		 *
		 * Added in JupyterHub 1.3
		 *
		 */
		state?: "inactive" | "active" | "ready";
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
		/**
		 * Include stopped servers in user model(s).
		 * Added in JupyterHub 3.0.
		 * Allows retrieval of information about stopped servers,
		 * such as activity and state fields.
		 *
		 */
		include_stopped_servers?: boolean;
		/**
		 * Sort users by this key (new in JupyterHub 5.0).
		 * Default: `id` (opaque but stable internal order).
		 * Supported fields: `id`, `name`, `last_activity`.
		 * Results will be in ascending order.
		 * Descending order can be requested with a `-` prefix,
		 * e.g. `sort=-last_activity` for most recently active users first.
		 *
		 */
		sort?: string;
	};
	url: "/users";
};

export type GetUsersResponses = {
	/**
	 * The Hub's user list
	 */
	200: Array<User>;
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type PostUsersData = {
	body: {
		/**
		 * list of usernames to create on the Hub
		 */
		usernames?: Array<string>;
		/**
		 * whether the created users should be admins
		 */
		admin?: boolean;
	};
	path?: never;
	query?: never;
	url: "/users";
};

export type PostUsersResponses = {
	/**
	 * The created users
	 */
	201: Array<User>;
};

export type PostUsersResponse = PostUsersResponses[keyof PostUsersResponses];

export type DeleteUserData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}";
};

export type DeleteUserResponses = {
	/**
	 * The user has been deleted
	 */
	204: void;
};

export type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];

export type GetUserData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: {
		/**
		 * Include stopped servers in user model(s).
		 */
		include_stopped_servers?: boolean;
	};
	url: "/users/{name}";
};

export type GetUserResponses = {
	/**
	 * The User model
	 */
	200: User;
};

export type GetUserResponse = GetUserResponses[keyof GetUserResponses];

export type PatchUserData = {
	/**
	 * Updated user info. At least one key to be updated (name or admin) is required.
	 */
	body: {
		/**
		 * the new name (optional, if another key is updated i.e. admin)
		 */
		name?: string;
		/**
		 * update admin (optional, if another key is updated i.e. name)
		 */
		admin?: boolean;
	};
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}";
};

export type PatchUserResponses = {
	/**
	 * The updated user info
	 */
	200: User;
};

export type PatchUserResponse = PatchUserResponses[keyof PatchUserResponses];

export type PostUserData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}";
};

export type PostUserResponses = {
	/**
	 * The user has been created
	 */
	201: User;
};

export type PostUserResponse = PostUserResponses[keyof PostUserResponses];

export type PostUserActivityData = {
	body?: {
		/**
		 * Timestamp of last-seen activity for this user.
		 * Only needed if this is not activity associated
		 * with using a given server.
		 *
		 */
		last_activity?: string;
		/**
		 * Register activity for specific servers by name.
		 * The keys of this dict are the names of servers.
		 * The default server has an empty name ('').
		 *
		 */
		servers?: {
			/**
			 * Activity for a single server.
			 *
			 */
			"<server name>"?: {
				/**
				 * Timestamp of last-seen activity on this server.
				 *
				 */
				last_activity: string;
			};
		};
	};
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}/activity";
};

export type PostUserActivityErrors = {
	/**
	 * Authentication/Authorization error
	 */
	401: unknown;
	/**
	 * No such user
	 */
	404: unknown;
};

export type PostUserActivityResponses = {
	/**
	 * Successfully updated activity
	 */
	200: unknown;
};

export type DeleteUserServerData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}/server";
};

export type DeleteUserServerResponses = {
	/**
	 * The user's notebook server has not yet stopped as it is taking a while to stop
	 */
	202: unknown;
	/**
	 * The user's notebook server has stopped
	 */
	204: void;
};

export type DeleteUserServerResponse =
	DeleteUserServerResponses[keyof DeleteUserServerResponses];

export type PostUserServerData = {
	/**
	 * Spawn options can be passed as a JSON body
	 * when spawning via the API instead of spawn form.
	 * The structure of the options
	 * will depend on the Spawner's configuration.
	 * The body itself will be available as `user_options` for the
	 * Spawner.
	 *
	 */
	body?: {
		[key: string]: unknown;
	};
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}/server";
};

export type PostUserServerResponses = {
	/**
	 * The user's notebook server has started
	 */
	201: unknown;
	/**
	 * The user's notebook server has not yet started, but has been requested
	 */
	202: unknown;
};

export type DeleteUserServerNameData = {
	body?: {
		/**
		 * Whether to fully remove the server, rather than just stop it.
		 * Removing a server deletes things like the state of the stopped server.
		 * Default: false.
		 *
		 */
		remove?: boolean;
	};
	path: {
		/**
		 * username
		 */
		name: string;
		/**
		 * name given to a named-server (empty string for default server).
		 *
		 * Note that depending on your JupyterHub infrastructure there are limitations to `server_name`. Default spawner with K8s pod will not allow Jupyter Notebooks to be spawned with a name that contains more than 253 characters (keep in mind that the pod will be spawned with extra characters to identify the user and hub).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/users/{name}/servers/{server_name}";
};

export type DeleteUserServerNameResponses = {
	/**
	 * The user's notebook named-server has not yet stopped as it is taking a while to stop
	 */
	202: unknown;
	/**
	 * The user's notebook named-server has stopped
	 */
	204: void;
};

export type DeleteUserServerNameResponse =
	DeleteUserServerNameResponses[keyof DeleteUserServerNameResponses];

export type PostUserServerNameData = {
	/**
	 * Spawn options can be passed as a JSON body
	 * when spawning via the API instead of spawn form.
	 * The structure of the options
	 * will depend on the Spawner's configuration.
	 *
	 */
	body?: {
		[key: string]: unknown;
	};
	path: {
		/**
		 * username
		 */
		name: string;
		/**
		 * name given to a named-server (empty string for default server).
		 *
		 * Note that depending on your JupyterHub infrastructure there are limitations to `server_name`. Default spawner with K8s pod will not allow Jupyter Notebooks to be spawned with a name that contains more than 253 characters (keep in mind that the pod will be spawned with extra characters to identify the user and hub).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/users/{name}/servers/{server_name}";
};

export type PostUserServerNameResponses = {
	/**
	 * The user's notebook named-server has started
	 */
	201: unknown;
	/**
	 * The user's notebook named-server has not yet started, but has been requested
	 */
	202: unknown;
};

export type GetUserSharedData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}/shared";
};

export type GetUserSharedResponses = {
	/**
	 * Shared access granted to the user
	 */
	200: PaginatedList & {
		items?: Array<ShareCode>;
	};
};

export type GetUserSharedResponse =
	GetUserSharedResponses[keyof GetUserSharedResponses];

export type DeleteUserSharedServerData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/users/{name}/shared/{owner}/{server_name}";
};

export type DeleteUserSharedServerResponses = {
	/**
	 * Permission has been revoked,
	 * the user no longer has access to the server.
	 *
	 */
	204: void;
};

export type DeleteUserSharedServerResponse =
	DeleteUserSharedServerResponses[keyof DeleteUserSharedServerResponses];

export type GetUserSharedServerData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/users/{name}/shared/{owner}/{server_name}";
};

export type GetUserSharedServerResponses = {
	/**
	 * The permissions granted to `user` on `owner/server`.
	 */
	200: Share;
};

export type GetUserSharedServerResponse =
	GetUserSharedServerResponses[keyof GetUserSharedServerResponses];

export type GetUserTokensData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}/tokens";
};

export type GetUserTokensErrors = {
	/**
	 * Authentication/Authorization error
	 */
	401: unknown;
	/**
	 * No such user
	 */
	404: unknown;
};

export type GetUserTokensResponses = {
	/**
	 * The list of tokens
	 */
	200: {
		api_tokens?: Array<Token>;
	};
};

export type GetUserTokensResponse =
	GetUserTokensResponses[keyof GetUserTokensResponses];

export type PostUserTokensData = {
	body?: {
		/**
		 * lifetime (in seconds) after which the requested token will expire. Omit, or specify null or 0 for no expiration.
		 */
		expires_in?: number;
		/**
		 * A note attached to the token for future bookkeeping
		 */
		note?: string;
		/**
		 * A list of role names from which to derive scopes.
		 * This is a shortcut for assigning collections of scopes;
		 * Tokens do not retain role assignment.
		 * (Changed in 3.0: roles are immediately resolved to scopes
		 * instead of stored on roles.)
		 *
		 */
		roles?: Array<string>;
		/**
		 * A list of scopes that the token should have.
		 * (new in JupyterHub 3.0).
		 *
		 */
		scopes?: Array<string>;
	};
	path: {
		/**
		 * username
		 */
		name: string;
	};
	query?: never;
	url: "/users/{name}/tokens";
};

export type PostUserTokensErrors = {
	/**
	 * Body must be a JSON dict or empty
	 */
	400: unknown;
	/**
	 * Requested role does not exist
	 */
	403: unknown;
};

export type PostUserTokensResponses = {
	/**
	 * The newly created token
	 */
	201: NewToken;
};

export type PostUserTokensResponse =
	PostUserTokensResponses[keyof PostUserTokensResponses];

export type DeleteUserTokenData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
		token_id: string;
	};
	query?: never;
	url: "/users/{name}/tokens/{token_id}";
};

export type DeleteUserTokenResponses = {
	/**
	 * The token has been deleted
	 */
	204: void;
};

export type DeleteUserTokenResponse =
	DeleteUserTokenResponses[keyof DeleteUserTokenResponses];

export type GetUserTokenData = {
	body?: never;
	path: {
		/**
		 * username
		 */
		name: string;
		token_id: string;
	};
	query?: never;
	url: "/users/{name}/tokens/{token_id}";
};

export type GetUserTokenResponses = {
	/**
	 * The info for the token
	 */
	200: Token;
};

export type GetUserTokenResponse =
	GetUserTokenResponses[keyof GetUserTokenResponses];

export type GetGroupsData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/groups";
};

export type GetGroupsResponses = {
	/**
	 * The list of groups
	 */
	200: Array<Group>;
};

export type GetGroupsResponse = GetGroupsResponses[keyof GetGroupsResponses];

export type DeleteGroupData = {
	body?: never;
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}";
};

export type DeleteGroupResponses = {
	/**
	 * The group has been deleted
	 */
	204: void;
};

export type DeleteGroupResponse =
	DeleteGroupResponses[keyof DeleteGroupResponses];

export type GetGroupData = {
	body?: never;
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}";
};

export type GetGroupResponses = {
	/**
	 * The group model
	 */
	200: Group;
};

export type GetGroupResponse = GetGroupResponses[keyof GetGroupResponses];

export type PostGroupData = {
	body?: never;
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}";
};

export type PostGroupResponses = {
	/**
	 * The group has been created
	 */
	201: Group;
};

export type PostGroupResponse = PostGroupResponses[keyof PostGroupResponses];

export type GetGroupSharedData = {
	body?: never;
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}/shared";
};

export type GetGroupSharedResponses = {
	/**
	 * Shared access granted to the group
	 */
	200: PaginatedList & {
		items?: Array<Share>;
	};
};

export type GetGroupSharedResponse =
	GetGroupSharedResponses[keyof GetGroupSharedResponses];

export type DeleteGroupSharedServerData = {
	body?: never;
	path: {
		/**
		 * group name
		 */
		name: string;
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/groups/{name}/shared/{owner}/{server_name}";
};

export type DeleteGroupSharedServerResponses = {
	/**
	 * Permission has been revoked,
	 * the group members no longer have access to the server.
	 *
	 */
	204: void;
};

export type DeleteGroupSharedServerResponse =
	DeleteGroupSharedServerResponses[keyof DeleteGroupSharedServerResponses];

export type GetGroupSharedServerData = {
	body?: never;
	path: {
		/**
		 * group name
		 */
		name: string;
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/groups/{name}/shared/{owner}/{server_name}";
};

export type GetGroupSharedServerResponses = {
	/**
	 * The permissions granted to members of `group` on `owner/server`
	 */
	200: Share;
};

export type GetGroupSharedServerResponse =
	GetGroupSharedServerResponses[keyof GetGroupSharedServerResponses];

export type DeleteGroupUsersData = {
	/**
	 * The users to remove from the group
	 */
	body: {
		/**
		 * List of usernames to remove from the group
		 */
		users?: Array<string>;
	};
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}/users";
};

export type DeleteGroupUsersResponses = {
	/**
	 * The users have been removed from the group
	 */
	200: unknown;
};

export type PostGroupUsersData = {
	/**
	 * The users to add to the group
	 */
	body: {
		/**
		 * List of usernames to add to the group
		 */
		users?: Array<string>;
	};
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}/users";
};

export type PostGroupUsersResponses = {
	/**
	 * The users have been added to the group
	 */
	200: Group;
};

export type PostGroupUsersResponse =
	PostGroupUsersResponses[keyof PostGroupUsersResponses];

export type PutGroupPropertiesData = {
	/**
	 * The new group properties, as a JSON dict.
	 */
	body: {
		[key: string]: unknown;
	};
	path: {
		/**
		 * group name
		 */
		name: string;
	};
	query?: never;
	url: "/groups/{name}/properties";
};

export type PutGroupPropertiesResponses = {
	/**
	 * The properties have been updated.
	 * The updated group model is returned.
	 *
	 */
	200: Group;
};

export type PutGroupPropertiesResponse =
	PutGroupPropertiesResponses[keyof PutGroupPropertiesResponses];

export type GetSharesOwnerData = {
	body?: never;
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
	};
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/shares/{owner}";
};

export type GetSharesOwnerResponses = {
	/**
	 * The list of shares for any of the user's servers
	 */
	200: PaginatedList & {
		items?: Array<Share>;
	};
};

export type GetSharesOwnerResponse =
	GetSharesOwnerResponses[keyof GetSharesOwnerResponses];

export type DeleteSharesServerData = {
	body?: never;
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/shares/{owner}/{server_name}";
};

export type DeleteSharesServerResponses = {
	/**
	 * All shares for the server have been deleted
	 *
	 */
	204: void;
};

export type DeleteSharesServerResponse =
	DeleteSharesServerResponses[keyof DeleteSharesServerResponses];

export type GetSharesServerData = {
	body?: never;
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/shares/{owner}/{server_name}";
};

export type GetSharesServerResponses = {
	/**
	 * The list of shares granting access to the given server
	 */
	200: PaginatedList & {
		items?: Array<Share>;
	};
};

export type GetSharesServerResponse =
	GetSharesServerResponses[keyof GetSharesServerResponses];

export type PatchSharesServerData = {
	/**
	 * The share modifications to be made, as a JSON dict.
	 */
	body: {
		/**
		 * group to revoke permissions from.
		 * Exactly one of 'user' and 'group' must be specified.
		 *
		 */
		group?: string;
		/**
		 * user to revoke permissions from.
		 * Exactly one of 'user' and 'group' must be specified.
		 *
		 */
		user?: string;
		/**
		 * scopes to revoke.
		 * If no scopes are specified, all permissions are revoked.
		 *
		 */
		scopes?: Array<string>;
	};
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/shares/{owner}/{server_name}";
};

export type PatchSharesServerResponses = {
	/**
	 * The updated Share permissions.
	 * An empty dict if no permissions remain.
	 *
	 */
	200: Share;
};

export type PatchSharesServerResponse =
	PatchSharesServerResponses[keyof PatchSharesServerResponses];

export type PostSharesServerData = {
	/**
	 * The new group properties, as a JSON dict.
	 */
	body: {
		/**
		 * group to grant permissions to.
		 * Exactly one of 'user' and 'group' can be specified.
		 *
		 */
		group?: string;
		/**
		 * user to grant permissions to.
		 * Exactly one of 'user' and 'group' can be specified.
		 *
		 */
		user?: string;
		/**
		 * scopes to grant
		 */
		scopes?: Array<string>;
	};
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/shares/{owner}/{server_name}";
};

export type PostSharesServerResponses = {
	/**
	 * The updated Share permissions
	 */
	200: Share;
};

export type PostSharesServerResponse =
	PostSharesServerResponses[keyof PostSharesServerResponses];

export type GetShareCodesOwnerData = {
	body?: never;
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
	};
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/share-codes/{owner}";
};

export type GetShareCodesOwnerResponses = {
	/**
	 * The list of share codes
	 */
	200: PaginatedList & {
		items?: Array<ShareCode>;
	};
};

export type GetShareCodesOwnerResponse =
	GetShareCodesOwnerResponses[keyof GetShareCodesOwnerResponses];

export type DeleteShareCodeData = {
	body?: never;
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: {
		/**
		 * the share code to revoke
		 */
		code?: string;
		/**
		 * the id of the share code to revoke
		 */
		id?: string;
	};
	url: "/share-codes/{owner}/{server_name}";
};

export type DeleteShareCodeResponses = {
	/**
	 * The share code has been revoked.
	 *
	 */
	204: void;
};

export type DeleteShareCodeResponse =
	DeleteShareCodeResponses[keyof DeleteShareCodeResponses];

export type GetShareCodesServerData = {
	body?: never;
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/share-codes/{owner}/{server_name}";
};

export type GetShareCodesServerResponses = {
	/**
	 * The list of share codes
	 */
	200: PaginatedList & {
		items?: Array<ShareCode>;
	};
};

export type GetShareCodesServerResponse =
	GetShareCodesServerResponses[keyof GetShareCodesServerResponses];

export type PostShareCodeData = {
	/**
	 * The new share code properties, as a JSON dict.
	 */
	body: {
		/**
		 * expiration in seconds.
		 * If unspecified, expires in one day (86400)
		 *
		 */
		expires_in?: number;
		/**
		 * scopes to grant
		 */
		scopes?: Array<string>;
	};
	path: {
		/**
		 * name of the user who owns the shared server
		 */
		owner: string;
		/**
		 * name of the shared server
		 * (empty string for default server, which means the URL ends with a trailing '/', e.g. `/username/`).
		 *
		 */
		server_name: string;
	};
	query?: never;
	url: "/share-codes/{owner}/{server_name}";
};

export type PostShareCodeResponses = {
	/**
	 * The Share code you just created.
	 * The code itself will be in the `code` field.
	 * The code is not stored by JupyterHub and cannot be retrieved a second time.
	 * `accept_url` will be the actual URL to share
	 * (it will look like `/hub/accept-share?code=abc123`).
	 *
	 */
	200: ShareCode & {
		/**
		 * The share code itself
		 */
		code?: string;
		/**
		 * The URL path for accepting the code
		 */
		accept_url?: string;
		/**
		 * The full URL for accepting the code,
		 * if JupyterHub.public_url configuration is defined.
		 *
		 */
		full_accept_url?: string | null;
	};
};

export type PostShareCodeResponse =
	PostShareCodeResponses[keyof PostShareCodeResponses];

export type GetServicesData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/services";
};

export type GetServicesResponses = {
	/**
	 * The service list
	 */
	200: Array<Service>;
};

export type GetServicesResponse =
	GetServicesResponses[keyof GetServicesResponses];

export type GetServiceData = {
	body?: never;
	path: {
		/**
		 * service name
		 */
		name: string;
	};
	query?: never;
	url: "/services/{name}";
};

export type GetServiceResponses = {
	/**
	 * The Service model
	 */
	200: Service;
};

export type GetServiceResponse = GetServiceResponses[keyof GetServiceResponses];

export type GetProxyData = {
	body?: never;
	path?: never;
	query?: {
		/**
		 * Return a number of results, starting at the specified offset.
		 * Can be used with limit to paginate.
		 * If unspecified, return all items.
		 *
		 */
		offset?: number;
		/**
		 * Return a finite number of results.
		 * Can be used with offset to paginate.
		 * If unspecified, use api_page_default_limit.
		 *
		 */
		limit?: number;
	};
	url: "/proxy";
};

export type GetProxyResponses = {
	/**
	 * configurable-http-proxy routing table (see configurable-http-proxy docs for details)
	 */
	200: {
		[key: string]: unknown;
	};
};

export type GetProxyResponse = GetProxyResponses[keyof GetProxyResponses];

export type PatchProxyData = {
	/**
	 * Any values that have changed for the new proxy. All keys are optional.
	 */
	body: {
		/**
		 * IP address of the new proxy
		 */
		ip?: string;
		/**
		 * Port of the new proxy
		 */
		port?: string;
		/**
		 * Protocol of new proxy, if changed
		 */
		protocol?: string;
		/**
		 * CONFIGPROXY_AUTH_TOKEN for the new proxy
		 */
		auth_token?: string;
	};
	path?: never;
	query?: never;
	url: "/proxy";
};

export type PatchProxyResponses = {
	/**
	 * Success
	 */
	200: unknown;
};

export type PostProxyData = {
	body?: never;
	path?: never;
	query?: never;
	url: "/proxy";
};

export type PostProxyResponses = {
	/**
	 * Success
	 */
	200: unknown;
};

export type PostAuthTokenData = {
	body?: {
		username?: string;
		password?: string;
	};
	path?: never;
	query?: never;
	url: "/authorizations/token";
};

export type PostAuthTokenErrors = {
	/**
	 * The user can not be authenticated.
	 */
	403: unknown;
};

export type PostAuthTokenResponses = {
	/**
	 * The new API token
	 */
	200: {
		/**
		 * The new API token.
		 */
		token?: string;
	};
};

export type PostAuthTokenResponse =
	PostAuthTokenResponses[keyof PostAuthTokenResponses];

export type GetAuthTokenData = {
	body?: never;
	path: {
		token: string;
	};
	query?: never;
	url: "/authorizations/token/{token}";
};

export type GetAuthTokenErrors = {
	/**
	 * A user or service is not found.
	 */
	404: unknown;
};

export type GetAuthTokenResponses = {
	/**
	 * The user or service identified by the API token
	 */
	200: unknown;
};

export type GetAuthCookieData = {
	body?: never;
	path: {
		cookie_name: string;
		cookie_value: string;
	};
	query?: never;
	url: "/authorizations/cookie/{cookie_name}/{cookie_value}";
};

export type GetAuthCookieErrors = {
	/**
	 * A user is not found.
	 */
	404: unknown;
};

export type GetAuthCookieResponses = {
	/**
	 * The user identified by the cookie
	 */
	200: User;
};

export type GetAuthCookieResponse =
	GetAuthCookieResponses[keyof GetAuthCookieResponses];

export type GetOauthAuthorizeData = {
	body?: never;
	path?: never;
	query: {
		/**
		 * The client id
		 */
		client_id: string;
		/**
		 * The response type (always 'code')
		 */
		response_type: string;
		/**
		 * A state string
		 */
		state?: string;
		/**
		 * The redirect url
		 */
		redirect_uri: string;
	};
	url: "/oauth2/authorize";
};

export type GetOauthAuthorizeErrors = {
	/**
	 * OAuth2Error
	 */
	400: unknown;
};

export type GetOauthAuthorizeResponses = {
	/**
	 * Success
	 */
	200: unknown;
};

export type PostOauthTokenData = {
	body: {
		/**
		 * The client id
		 */
		client_id: string;
		/**
		 * The client secret
		 */
		client_secret: string;
		/**
		 * The grant type (always 'authorization_code')
		 */
		grant_type: "authorization_code";
		/**
		 * The code provided by the authorization redirect
		 */
		code: string;
		/**
		 * The redirect url
		 */
		redirect_uri: string;
	};
	path?: never;
	query?: never;
	url: "/oauth2/token";
};

export type PostOauthTokenResponses = {
	/**
	 * JSON response including the token
	 */
	200: {
		/**
		 * The new API token for the user
		 */
		access_token?: string;
		/**
		 * Will always be 'Bearer'
		 */
		token_type?: string;
	};
};

export type PostOauthTokenResponse =
	PostOauthTokenResponses[keyof PostOauthTokenResponses];

export type PostShutdownData = {
	body?: {
		/**
		 * Whether the proxy should be shutdown as well (default from Hub config)
		 */
		proxy?: boolean;
		/**
		 * Whether users' notebook servers should be shutdown as well (default from Hub config)
		 */
		servers?: boolean;
	};
	path?: never;
	query?: never;
	url: "/shutdown";
};

export type PostShutdownErrors = {
	/**
	 * Unexpected value for proxy or servers
	 */
	400: unknown;
};

export type PostShutdownResponses = {
	/**
	 * Shutdown successful
	 */
	202: unknown;
};
